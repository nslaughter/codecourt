# CodeCourt Monitoring Guide

This document provides information on how to use the monitoring and observability capabilities integrated with CodeCourt using the kube-prometheus-stack, OpenTelemetry, and Jaeger.

## Overview

CodeCourt integrates the kube-prometheus-stack, which provides a robust monitoring solution for Kubernetes clusters and applications. The monitoring stack has been enhanced with distributed tracing capabilities using OpenTelemetry and Jaeger. The observability components include:

- **Prometheus**: A time-series database for storing metrics
- **Grafana**: A visualization tool for metrics
- **AlertManager**: A tool for handling alerts
- **Node Exporter**: Collects hardware and OS metrics
- **kube-state-metrics**: Collects metrics about the state of Kubernetes objects
- **OpenTelemetry Collector**: Collects and processes telemetry data (traces, metrics)
- **Jaeger**: Distributed tracing system for monitoring and troubleshooting microservices

## Accessing the Monitoring Tools

### Prometheus

To access the Prometheus UI:

```bash
# Port-forward the Prometheus service
kubectl port-forward -n codecourt svc/codecourt-kube-prometheus-prometheus 9090:9090
```

Then open your browser and navigate to [http://localhost:9090](http://localhost:9090)

### Grafana

To access the Grafana dashboard:

```bash
# Port-forward the Grafana service
kubectl port-forward -n codecourt svc/codecourt-grafana 3000:80
```

Then open your browser and navigate to [http://localhost:3000](http://localhost:3000)

Default login credentials:

- Username: admin
- Password: admin (configurable in values.yaml)

### AlertManager

To access the AlertManager UI:

```bash
# Port-forward the AlertManager service
kubectl port-forward -n codecourt svc/codecourt-kube-prometheus-alertmanager 9093:9093
```

Then open your browser and navigate to [http://localhost:9093](http://localhost:9093)

### Jaeger

To access the Jaeger UI:

```bash
# Port-forward the Jaeger service
kubectl port-forward -n codecourt svc/codecourt-jaeger 16686:16686
```

Then open your browser and navigate to [http://localhost:16686](http://localhost:16686)

Alternatively, if you've configured the Jaeger ingress, you can access it at [http://jaeger.codecourt.local](http://jaeger.codecourt.local)

## Available Dashboards

The following pre-configured dashboards are available in Grafana:

1. **Kafka Overview**: Metrics related to Kafka brokers and topics
2. **PostgreSQL Overview**: Metrics related to PostgreSQL databases
3. **CodeCourt Services**: Metrics related to CodeCourt microservices

To access these dashboards, navigate to Grafana and select the dashboard from the "CodeCourt" folder.

## Metrics Collection

### Service Metrics

Each CodeCourt service exposes metrics at the `/metrics` endpoint, which are scraped by Prometheus every 15 seconds. These metrics include:

- HTTP request counts and latencies
- Error rates
- Resource usage (CPU, memory)
- Custom business metrics

### Infrastructure Metrics

The monitoring stack also collects metrics about the Kubernetes infrastructure:

- Node metrics (CPU, memory, disk, network)
- Pod and container metrics
- Kubernetes object metrics (deployments, statefulsets, etc.)

## Alerting

AlertManager is configured to handle alerts generated by Prometheus. The default configuration:

- Groups alerts by job
- Waits 30 seconds before initially sending a group of alerts
- Waits 5 minutes before sending a notification about new alerts for a group
- Waits 12 hours before resending an alert if it hasn't been resolved

## Customizing the Monitoring Stack

### Adding Custom Dashboards

To add custom Grafana dashboards, you can:

1. Export the dashboard JSON from Grafana
2. Save the JSON file in the `helm/codecourt/dashboards/` directory
3. Update the `values.yaml` file to reference the dashboard file under `kube-prometheus-stack.grafana.dashboards.codecourt`

### Dashboard Linting

All Grafana dashboards in CodeCourt are validated using the [Grafana Dashboard Linter](https://github.com/grafana/dashboard-linter) to ensure they follow best practices and will work correctly in Grafana. The linter checks for issues such as:

- Missing panel titles
- Incorrect grid positioning
- Missing datasources
- Duplicate panels
- Empty panels

To lint dashboards locally:

```bash
# Install the linter if you haven't already
go install github.com/grafana/dashboard-linter@latest

# Run the dashboard linting script
./scripts/lint-dashboards.sh
```

The dashboard linter is also integrated into the CI/CD pipeline to ensure all dashboards are validated before deployment. When creating or modifying dashboards, make sure they pass the linting checks before committing changes.

### Modifying Prometheus Rules

To add or modify Prometheus alerting rules:

1. Edit the `values.yaml` file under `kube-prometheus-stack.prometheus.prometheusSpec.ruleSelector`
2. Create a new PrometheusRule resource in the templates directory

Example:

```yaml
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: codecourt-alerts
  labels:
    release: codecourt
spec:
  groups:
  - name: codecourt.rules
    rules:
    - alert: HighErrorRate
      expr: sum(rate(http_requests_total{status=~"5.."}[5m])) / sum(rate(http_requests_total[5m])) > 0.1
      for: 5m
      labels:
        severity: critical
      annotations:
        summary: High HTTP error rate
        description: More than 10% of requests are failing with 5xx errors for the past 5 minutes.
```

### Configuring Resource Limits

To adjust the resource limits for the monitoring components, modify the corresponding sections in the `values.yaml` file:

```yaml
kube-prometheus-stack:
  prometheus:
    prometheusSpec:
      resources:
        requests:
          cpu: 200m
          memory: 512Mi
        limits:
          cpu: 1000m
          memory: 2Gi
```

## Distributed Tracing

CodeCourt implements distributed tracing using OpenTelemetry and Jaeger. For detailed information, see the [DISTRIBUTED_TRACING.md](./DISTRIBUTED_TRACING.md) document.

### Trace Collection

Each CodeCourt service is instrumented with OpenTelemetry to generate traces. The traces are collected by the OpenTelemetry Collector and sent to Jaeger for storage and visualization.

### Viewing Traces

To view traces, access the Jaeger UI as described above. The UI allows you to:

- Search for traces by service, operation, tags, and time range
- View detailed trace information including spans, tags, and logs
- Compare traces side by side
- Analyze trace statistics

### Trace Context Propagation

CodeCourt services propagate trace context using the W3C Trace Context standard. This allows traces to flow across service boundaries, providing end-to-end visibility of requests.

### Integration with Metrics

Traces can be correlated with metrics in Grafana using the Trace ID. This allows you to navigate from a metric spike to the corresponding traces, helping to identify the root cause of issues.

## Troubleshooting

### Common Issues

1. **Prometheus not scraping metrics**:
   - Check if ServiceMonitor resources are created
   - Verify service labels match ServiceMonitor selectors
   - Check if metrics endpoints are accessible

2. **Grafana dashboards not showing data**:
   - Verify Prometheus data source is configured correctly
   - Check if metrics are available in Prometheus
   - Inspect Grafana logs for errors

3. **High resource usage**:
   - Adjust scrape intervals
   - Reduce retention period
   - Increase resource limits

### Viewing Logs

```bash
# Prometheus logs
kubectl logs -n codecourt -l app=prometheus

# Grafana logs
kubectl logs -n codecourt -l app.kubernetes.io/name=grafana

# AlertManager logs
kubectl logs -n codecourt -l app=alertmanager

# Jaeger logs
kubectl logs -n codecourt -l app.kubernetes.io/component=jaeger

# OpenTelemetry Collector logs
kubectl logs -n codecourt -l app.kubernetes.io/component=otel-collector
```

## Best Practices

1. **Resource Planning**: Ensure sufficient resources are allocated to monitoring components
2. **Alert Tuning**: Adjust alert thresholds to reduce noise
3. **Dashboard Organization**: Keep dashboards focused and organized by service or function
4. **Retention Policies**: Configure appropriate data retention based on storage capacity
5. **Access Control**: Implement proper authentication and authorization for monitoring tools
6. **Dashboard Quality**: Follow Grafana dashboard best practices and ensure all dashboards pass linting checks
7. **Consistent Naming**: Use consistent naming conventions for metrics, labels, and dashboard elements
8. **Documentation**: Add descriptions to panels and dashboards to help users understand the metrics

## Future Enhancements

While the current monitoring stack provides robust metrics collection and visualization, there are several potential enhancements that could be implemented in the future:

1. **Distributed Tracing**: Integrate tools like Jaeger or Zipkin to provide distributed tracing capabilities, allowing for end-to-end request tracking across microservices
2. **Log Aggregation**: Add centralized logging with tools like Loki or Elasticsearch/Fluentd/Kibana (EFK) stack
3. **Custom Service Level Objectives (SLOs)**: Implement SLO monitoring and alerting based on key performance indicators
4. **Enhanced Business Metrics**: Add more domain-specific metrics related to coding challenges, submissions, and user activity

## Conclusion

The integrated monitoring stack provides robust visibility into the CodeCourt system, helping to identify issues, track performance, and ensure reliability. By leveraging these tools, you can gain insights into system behavior and proactively address potential problems. While the current implementation focuses on metrics and dashboards, future enhancements could expand the observability capabilities to include distributed tracing and more sophisticated monitoring features.
